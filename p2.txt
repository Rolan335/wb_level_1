1. Какой самый эффективный способ конкатенации строк?

С помощью метода Builder пакета strings

2. Что такое интерфейсы, как они применяются в Go?

Это специальный тип данных, хранящий набор методов, которые должны быть реализованы.
Интерфейсы абстрагиются от типов данных, поэтому мы можем использовать один и тот же код с разными типами данных.

3. Чем отличаются RWMutex от Mutex?

Mutex - полностью блокирует общий ресурс для чтения и записи
RWMutex - Позволяет заблокировать запись, но оставить чтение.

4. Чем отличаются буферизированные и не буферизированные каналы?

не буферизированный канал имеет длину 1, в него нельзя отправить следующее сообщение, пока предыдущее не будет прочитано.
буферизированный - имеет кастомную длину (make(chan struct{}, n)). Соответственно, можно отправить несколько сообщений


5. Какой размер у структуры struct{}{}?

0 байт

6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

Порядок вывода не гарантирован. Тип map реализован как хэш-таблица, и порядок элементов может меняться
при каждой итерации 

8. В чем разница make и new?

make используется только для создания срезов, мап и каналов и возвращает экземпляр типа который мы указали.

new выделяет память для переменной указанного типа и возвращает указатель на неё.

9. Сколько существует способов задать переменную типа slice или map?

	var a map[int]int
	b := make(map[int]int)

10. Что выведет данная программа и почему?
func update(p *int) {
b := 2
p = &b
}
func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}

Выведет 1 1. В функции update() создаётся копия указателя p, копия не повлияет на изначальную переменную-указатель из функции main.

11. Что выведет данная программа и почему?
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}

deadlock. waitgroup не отработает как надо, потому что мы передаём копию переменной, а не указатель.
Из-за этого у каждой горутины появляется собственное значение wg, что делает waitgroup бесмысленным.

12. Что выведет данная программа и почему?
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}

0. Внутри if создаётся новая переменная n со своей областью видимости, которая никак не влияет на n внутри main.

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}
func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}

[100 2 3 4 5]. append создаст новый массив, так как в изначальном (а) нету места

14. Что выведет данная программа и почему?
func main() {
slice := []string{"a", "a"}
func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}

[b b a][a a] первым выведется слайс анонимной функции, он никак не изменил слайс в main, а создал его копию.